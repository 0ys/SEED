package org.example.backend.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.backend.domain.gitlab.service.GitlabService;
import org.example.backend.domain.selfcicd.service.CICDResolverService;
import org.example.backend.util.fastai.FastAIClient;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/self-cicd")
@RequiredArgsConstructor
@Slf4j
public class CICDResolverController {

    private final CICDResolverService cicdResolverService;
    private final FastAIClient fastAIClient;
    private final GitlabService gitlabService;
    private final ObjectMapper objectMapper;

//    /**
//     * Jenkins 워크플로우에서 빌드 실패 시 호출할 엔드포인트
//     * - Authorization 헤더에 Bearer <cicdToken>
//     * - body에는 buildNumber만 전달
//     */
//    @PostMapping("/resolve")
//    @Operation(summary = "CI/CD 셀프 힐링 트리거", security = @SecurityRequirement(name = "JWT"))
//    public ResponseEntity<ApiResponse<String>> triggerSelfHealingCI(
//            @RequestParam Long projectId,
//            @RequestHeader(name = HttpHeaders.AUTHORIZATION) String accessToken
//    ) {
//        cicdResolverService.handleSelfHealingCI(projectId, accessToken);
//        return ResponseEntity.ok(ApiResponse.success("🔧 셀프 힐링 작업이 트리거되었습니다."));
//    }
//
//    @PostMapping("/simulate")
//    public ResponseEntity<ApiResponse<List<PatchedFile>>> simulateSelfHealing(
//            @RequestBody SimulationRequestDto request
//    ) {
//        String accessToken = request.getAccessToken();
//        Long projectId = request.getProjectId();
//        String jenkinsErrorLog = request.getJenkinsErrorLog();
//
//        List<GitlabCompareDiff> gitDiff = request.getGitDiff();
//        Map<String, String> appLogs = request.getAppLogs();
//        List<Map<String, String>> allTrees = request.getTree();
//        List<String> appNames = request.getApplicationNames();
//
//        Map<String, String> appToFolderMap = Map.of(
//                "spring", "backend",
//                "react", "frontend"
//        );
//
//        // 3. 앱 추론
//        InferAppRequest inferRequest = InferAppRequest.builder()
//                .gitDiff(gitDiff)
//                .jenkinsLog(jenkinsErrorLog)
//                .applicationNames(appNames)
//                .build();
//
//        List<String> suspectedApps = fastAIClient.requestInferApplications(inferRequest);
//
//        // 4. 트리 매핑
//        Map<String, List<GitlabTree>> appTrees = new HashMap<>();
//        for (String appName : suspectedApps) {
//            String folder = appToFolderMap.getOrDefault(appName, appName); // ✅ 수정
//            List<GitlabTree> parsedTree = allTrees.stream()
//                    .filter(node -> node.get("path").startsWith(folder + "/"))
//                    .map(node -> objectMapper.convertValue(node, GitlabTree.class))
//                    .collect(Collectors.toList());
//            appTrees.put(appName, parsedTree);
//        }
//
//        List<PatchedFile> patchedFiles = new ArrayList<>();
//
//        for (String appName : suspectedApps) {
//            String appLog = appLogs.get(appName);
//            List<GitlabTree> tree = appTrees.get(appName);
//
//            Map<String, Object> diffRawPayload = new HashMap<>();
//            diffRawPayload.put("commit", Map.of(
//                    "title", "auto-generated commit",
//                    "message", "generated by simulateSelfHealing()"
//            ));
//            diffRawPayload.put("diffs", gitDiff);
//
//            String diffJson;
//            try {
//                diffJson = objectMapper.writeValueAsString(diffRawPayload);
//            } catch (JsonProcessingException e) {
//                throw new BusinessException(ErrorCode.AI_JSON_PROCESSING_FAILED);
//            }
//
//            String aiRaw = fastAIClient.requestSuspectFiles(diffJson, tree.toString(), appLog);
//
//            JsonNode aiResponse;
//            try {
//                aiResponse = objectMapper.readTree(aiRaw).get("response");
//            } catch (JsonProcessingException e) {
//                throw new BusinessException(ErrorCode.AI_JSON_PROCESSING_FAILED);
//            }
//
//            String summary = aiResponse.get("errorSummary").asText();
//            String cause = aiResponse.get("cause").asText();
//            String hint = aiResponse.get("resolutionHint").asText();
//
//            List<Map<String, String>> filesRaw = new ArrayList<>();
//            for (JsonNode f : aiResponse.get("suspectFiles")) {
//                String path = f.get("path").asText();
//                String code = gitlabService.getRawFileContent(accessToken, projectId, path, "master");
//                filesRaw.add(Map.of("path", path, "code", code));
//            }
//
//            String rawJson;
//            try {
//                rawJson = objectMapper.writeValueAsString(filesRaw);
//            } catch (JsonProcessingException e) {
//                throw new BusinessException(ErrorCode.AI_JSON_PROCESSING_FAILED);
//            }
//
//            String resolveResp;
//            try {
//                resolveResp = fastAIClient.requestResolveError(summary, cause, hint, rawJson);
//            } catch (Exception e) {
//                throw new BusinessException(ErrorCode.AI_JSON_PROCESSING_FAILED);
//            }
//
//            JsonNode fileFixes;
//            try {
//                fileFixes = objectMapper.readTree(resolveResp).get("fileFixes");
//            } catch (JsonProcessingException e) {
//                throw new BusinessException(ErrorCode.AI_JSON_PROCESSING_FAILED);
//            }
//
//            for (JsonNode fix : fileFixes) {
//                String path = fix.get("path").asText();
//                String instruction = fix.get("instruction").asText();
//                String code = filesRaw.stream()
//                        .filter(f -> f.get("path").equals(path))
//                        .findFirst()
//                        .map(f -> f.get("code"))
//                        .orElse("");
//
//                PatchedFile patch = fastAIClient.requestPatchFile(path, code, instruction);
//                patchedFiles.add(patch);
//            }
//        }
//        return ResponseEntity.ok(ApiResponse.success(patchedFiles));
//    }
}